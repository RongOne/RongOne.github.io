{"meta":{"title":"RONG的博客","subtitle":"Don't think, just solve.","description":"内蒙古科技大学15届，信息工程学院计算机专业。","author":"Mr.Rong","url":"https://rongone.github.io","root":"/"},"pages":[{"title":"","date":"2019-10-23T12:43:09.832Z","updated":"2019-10-23T12:43:09.832Z","comments":true,"path":"404.html","permalink":"https://rongone.github.io/404.html","excerpt":"","text":"404"},{"title":"","date":"2019-10-20T12:53:07.484Z","updated":"2019-10-20T12:53:07.484Z","comments":true,"path":"html/404.html","permalink":"https://rongone.github.io/html/404.html","excerpt":"","text":""},{"title":"关于","date":"2019-10-20T14:10:01.000Z","updated":"2019-10-20T14:12:47.071Z","comments":true,"path":"about/index.html","permalink":"https://rongone.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-10-20T14:05:07.000Z","updated":"2019-10-30T13:54:32.419Z","comments":true,"path":"categories/index.html","permalink":"https://rongone.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-10-20T14:09:10.000Z","updated":"2019-10-30T13:55:17.694Z","comments":true,"path":"tags/index.html","permalink":"https://rongone.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【转】JS计算保留小数位数并且不补0","slug":"【转】JS计算保留小数位数并且不补0","date":"2019-10-25T13:24:40.000Z","updated":"2019-10-25T13:36:16.685Z","comments":true,"path":"2019/10/25/【转】JS计算保留小数位数并且不补0/","link":"","permalink":"https://rongone.github.io/2019/10/25/【转】JS计算保留小数位数并且不补0/","excerpt":"实际项目当中遇到这样一个问题，就是js计算会出现无穷大小数，所以选择用toFixed(num)方法，其中num设置过大，小数点后位数不够会用0进行补位，用户体验非常不好。 js计算会出现无穷大数的原因js中只有Number一种类型，并且 Number采用的时IEEE 754 64位双精度浮点数编码 。比如0.1 + 0.2 = 0.30000000000000004，计算时会把0.1和0.2转换成二进制数，计算后在转成十进制就成了0.30000000000000004。 将每个浮点数乘以10的N次方，计算完成后再除以10的N次方 12345formatFloat(f,digit)&#123; let m = Math.pow(10, digit); let num = Math.round(f * m) / m; return num;&#125; f是计算表达式，digit是需要乘以10的多少次方。比如：formatFloat(0.1+0.2,2);return返回的结果是：0.3","text":"实际项目当中遇到这样一个问题，就是js计算会出现无穷大小数，所以选择用toFixed(num)方法，其中num设置过大，小数点后位数不够会用0进行补位，用户体验非常不好。 js计算会出现无穷大数的原因js中只有Number一种类型，并且 Number采用的时IEEE 754 64位双精度浮点数编码 。比如0.1 + 0.2 = 0.30000000000000004，计算时会把0.1和0.2转换成二进制数，计算后在转成十进制就成了0.30000000000000004。 将每个浮点数乘以10的N次方，计算完成后再除以10的N次方 12345formatFloat(f,digit)&#123; let m = Math.pow(10, digit); let num = Math.round(f * m) / m; return num;&#125; f是计算表达式，digit是需要乘以10的多少次方。比如：formatFloat(0.1+0.2,2);return返回的结果是：0.3 toFixed()方法舍入规则toFixed()方法使用的是银行家舍入规则。四舍六入五成双，即“4舍6入5凑偶”这里“四”是指≤4 时舍去，”六”是指≥6时进上，”五”指的是根据5后面的数字来定，当5后有数时，舍5入1；当5后无有效数字时，需要分两种情况来讲：①5前为奇数，舍5入1；②5前为偶数，舍5不进。（0是偶数） 最终解决方案123456789101112Number.prototype.fixed=function(len)&#123; len=isNaN(len)?0:len var num=Math.pow(10,len) return Math.round(this*num)/num &#125;//testNumber('').fixed()Number('213412DDD').fixed()1234.152354.fixed()1234.152354.fixed(2)1234.152354.fixed(10) 根据以上方法就可以既保留小数位数，并且位数不足时不在补0。","categories":[{"name":"前端","slug":"前端","permalink":"https://rongone.github.io/categories/前端/"}],"tags":[{"name":"JS","slug":"JS","permalink":"https://rongone.github.io/tags/JS/"}]},{"title":"SQL语句中等于、不等于和空的区别","slug":"SQL语句中等于、不等于和空的区别","date":"2019-10-18T13:33:25.000Z","updated":"2019-10-25T13:45:08.228Z","comments":true,"path":"2019/10/18/SQL语句中等于、不等于和空的区别/","link":"","permalink":"https://rongone.github.io/2019/10/18/SQL语句中等于、不等于和空的区别/","excerpt":"在数据库查询当中，SQL中不等于使用&lt;&gt;，等于用=，null使用IS NULL和IS NOT NULL进行查询。转自小桐博客 sql中的等于和不等于， ‘=’ ,’!=’,’&lt;&gt;’,’is null’等 等于：=不等于：尽量使用&lt;&gt;表示不等于。&lt;&gt;，!=，~=，^=这四个符号据说都可以在oracle中表示不等于，但是试了之后发现&lt;&gt;，!=，^=是可以的，~=不行,需要注意的是，只有&lt;&gt;是标准的SQL语法，可以移植，其他的都是Oracle平台的特性，移植性较差。 is null和is not null要进行null的等于判断时，须使用is null或is not null，null只能通过is null或者is not null来判断，其它操作符与null操作都是false。","text":"在数据库查询当中，SQL中不等于使用&lt;&gt;，等于用=，null使用IS NULL和IS NOT NULL进行查询。转自小桐博客 sql中的等于和不等于， ‘=’ ,’!=’,’&lt;&gt;’,’is null’等 等于：=不等于：尽量使用&lt;&gt;表示不等于。&lt;&gt;，!=，~=，^=这四个符号据说都可以在oracle中表示不等于，但是试了之后发现&lt;&gt;，!=，^=是可以的，~=不行,需要注意的是，只有&lt;&gt;是标准的SQL语法，可以移植，其他的都是Oracle平台的特性，移植性较差。 is null和is not null要进行null的等于判断时，须使用is null或is not null，null只能通过is null或者is not null来判断，其它操作符与null操作都是false。 例子：select * from bl_ip_dt where amount &lt;&gt; 800,这条语句查不出amount等于null 的记录，select * from bl_ip_dt where amount &lt;&gt; 800 or amount is null 才是可以的.","categories":[{"name":"数据库","slug":"数据库","permalink":"https://rongone.github.io/categories/数据库/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://rongone.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"https://rongone.github.io/tags/数据库/"}]},{"title":"Oracle删除用户时候报错ORA-01940无法删除当前已连接用户","slug":"Oracle删除用户时候报错ORA-01940无法删除当前已连接用户","date":"2019-10-16T13:43:02.000Z","updated":"2019-10-20T14:07:45.519Z","comments":true,"path":"2019/10/16/Oracle删除用户时候报错ORA-01940无法删除当前已连接用户/","link":"","permalink":"https://rongone.github.io/2019/10/16/Oracle删除用户时候报错ORA-01940无法删除当前已连接用户/","excerpt":"1、根据用户名查询v$session表1select username,sid,serial# from v$session where username=&apos;TECIDREPORTUSER&apos;;","text":"1、根据用户名查询v$session表1select username,sid,serial# from v$session where username=&apos;TECIDREPORTUSER&apos;; 2、根据SID SERIAL值kill掉1alter system kill session &apos;158,2270&apos;; 3、查看status值是否为killer1select saddr,sid,serial#,paddr,username,status from v$session where username = &apos;TECIDREPORTUSER&apos;; 4、删除用户1drop user TECIDREPORTUSER cascade; （或者手动drop掉）","categories":[{"name":"数据库","slug":"数据库","permalink":"https://rongone.github.io/categories/数据库/"}],"tags":[{"name":"数据库,Oracle","slug":"数据库-Oracle","permalink":"https://rongone.github.io/tags/数据库-Oracle/"}]},{"title":"C#基础随笔","slug":"C-笔记记录","date":"2019-10-14T13:37:15.000Z","updated":"2019-10-20T12:18:54.000Z","comments":true,"path":"2019/10/14/C-笔记记录/","link":"","permalink":"https://rongone.github.io/2019/10/14/C-笔记记录/","excerpt":"C#第一天数据类型 int //整数类型 只能存储整数 double //小数类型 既能存储小数 也能存储整数 string //字符串 用来存储多个文本，也可也存储空，需要用双引号 string ss = “”;//可以存空 char //字符类型 用来存储单个字符，最多最少只能有一个字符 char = ‘男’; //金钱类型 值后面要加个m，精度28到29位有效位 decimal money = 5000m;","text":"C#第一天数据类型 int //整数类型 只能存储整数 double //小数类型 既能存储小数 也能存储整数 string //字符串 用来存储多个文本，也可也存储空，需要用双引号 string ss = “”;//可以存空 char //字符类型 用来存储单个字符，最多最少只能有一个字符 char = ‘男’; //金钱类型 值后面要加个m，精度28到29位有效位 decimal money = 5000m; 命名空间可以认为类是属于命名空间的如果在当前项目中没有这个类的命名空间，需要我们手动的导入这个类所在的命名空间。 用鼠标去点 alt + shift +f10 记住命名空间，手动的去引用在一个项目中引用另一个项目的类 添加引用 引用命名空间 值类型 引用类型 12345&#123; 字段; 属性; 方法;&#125; 写好了一个类之后，我们需要创建这个类的对象，那么，我们管创建这个类的对象过程称之为类的实例化。使用关键字 new。this：表示当前这个类的对象。类是不占内存的，而对象是占内存的。 属性属性的作用就是保护字段、对字段的赋值和取值进行限定。属性的本质就是两个方法，一个叫get() 一个叫set()。 Field(字段) Method(方法) Property(属性)12345public string Name&#123; get &#123; return _name;&#125; set &#123; _name = value;&#125;&#125; static 静态和非静态的区别 在非静态类中，既可以有实例成员，也可以有静态成员 在调用实例成员的时候，需要使用对象名、实例成员； 在调用静态成员的时候，需要使用类名、静态成员名； 总结：静态成员 方法、字段、属性等 需要类名调用。如：Console.WriteLine();非静态成员 需要对象调 .Net第七天笔记不管是实参还是形参，都是在内存中开辟了空间的。方法的功能一定要单一。 1GetMax(int n1,int n2) 方法中最忌讳的就是出现提示用户输入的字眼。 out、ref、params1、out参数如果你在一个方法中，返回多个相同类型的值得时候，可以考虑返回一个数组。但是，如果返回多个不同类型的值得时候，返回数组就不行了，那么这个时候，我们可以考虑使用out参数。out参数就侧重于在一个方法中可以返回多个不同类型的值。 2、ref参数能够将一个变量带入一个方法中进行改变，改变完成后，再将改变后的值带出方法。ref参数要求在方法外必须为其赋值，而方法内可以不赋值。 3、params可变参数将实参列表中跟可变参数数组类型一致的元素都当作数组的元素去处理。params可变参数必须是形参列表中的最后一个元素。 方法的重载概念：方法的重载指的就是方法的名称相同，但是参数不同。参数不同，分为两种情况如果参数的个数相同，那么参数的类型就不能相同。如果参数的类型相同，那么参数的个数就不能相同。方法的重载跟返回值没有关系。 方法的递归方法自己调用自己。找出一个文件夹内所有的文件。 第九天我们把这些具有相同属性和相同方法的对象进行进一步的封装，抽象出来 类这个概念，累就是个模子，确定了对象应该具有的属性和方法。对象是根据类创建出来的。类就是一个盖大楼的图纸 对象就是盖出来的大楼。 2、类语法: 123456[public] class 类名&#123; 字段; 属性; 方法;&#125; 字段：存储数据存储多个值 方法：描述行为 写好一个类之后，我们需要创建这个类的对象，那么，我们管创建这个类的对象的过程称之为类的实例化。使用关键字 new this:表示当前这个类的对象 结构的语法 1234567891011public struct PersonTwo&#123; public sring _name; public int _age; public char _gender; public void CHLAS() &#123; Console.WriteLine(&quot;姓名是&#123;0&#125;,年龄是&#123;1&#125;,性别是&#123;2&#125;&quot;,this._name,this._age,this._gender); &#125;&#125; 结构的语法和类的语法很像，但是不是，因为不具备类的三个特征。封装 继承 多态 3、属性属性的作用就是保护字段、对字段的赋值和取值进行限定。属性的本质就是两个方法，一个叫get()一个叫set()Field字段Method方法Property属性 public:公开的公共的 在哪都能访问private:私有的，只能在当前类的内部进行访问，出了这个类就访问不到了 5、当我们创建好一个类的对象后，需要给这个对象的每个属性去赋值，我们管这个过程称之为对象的初始化。 6、静态和非静态的区别 在非静态类中，既可以有实例成员，也可以有静态成员。 在调用实例成员的时候，需要使用对象名.实例成员 在调用静态成员的时候，需要使用类名.静态成员名 总结：静态成员必须使用类名去调用，而实例成员使用对象名去调用。静态函数中，只能访问静态成员，不允许访问实例成员。实例函数中，既可以使用静态成员，也可以使用实例成员。静态类中只允许有静态成员，不允许有实例成员。 静态类不允许被实例化，创建对象也没用，调用的时候都是用类名去调用的。使用：如果你想要你的类当作一个“工具类”去使用，这个时候可以考虑将类写成静态成员。静态类在整个项目中资源共享。类是不占内存的，对象是占内存的 只有在程序全部结束之后，静态类才会释放资源。堆 栈 静态存储区域释放资源：GC Garbage Collection垃圾回收器 7、构造函数作用：帮助我们初始化对象（给对象的每个属性依次的赋值） 构造函数是一个特殊的方法： 构造函数没有返回值，连void也不能写。 构造函数的名称必须跟类名一样。 创建对象的时候会执行构造函数构造函数是可以有重载的 类当中会有一个默认的无参数的构造函数，当你写了一个新的构造函数之后，不管是有参数 还是无参数的，那个默认的无参数的构造函数都被干掉了。 8、new关键字Person zsPerson=new Person();new帮助我们做了三件事 在内存中开辟一块空间 在开辟的空间中创建对象 调用对象的构造函数进行初始化对象。9、this关键字 代表当前类的对象 在类当中显示的调用本类的构造函数 :this 析构函数//当程序结束的时候 析构函数才执行帮助我们释放资源 1234~Student()&#123;&#125; 第十天1、命名空间可以认为类是属于命名空间的。如果在当前项目中没有这个累的命名空间，需要我们手动的导入这个类所在的命名空间。 用鼠标去点 alt+shift+F10 记住命名空间，手动的去引用2、在一个项目中引用另一个项目的类 添加引用 引用命名空间值类型和引用类型区别：1、值类型和引用类型在内存上存储的地方不一样。2、在传递值类型和传递引用类型的时候，传递的方式不一样。值类型我们称之为值传递，引用类型我们称之为引用传递。我们学的值类型和引用类型：值类型：int double bool char decimal struct enum整数 小数 布尔类型 字符类型 金钱 结构 枚举引用类型： string 自定义类 数组存储：值类型的值是存储在内存的栈当中。引用类型的值是存储在内存的堆中 字符串 字符串的不可变性当你给一个字符串重新赋值之后，老值并没有销毁，而是重新开辟一块空间存储新值。当程序结束后，GC扫描整个内存，如果发现有的空间没有被指向，则立即把它销毁。 我们可以将字符串看作是char类型的一个只读数组ToCharArray();将字符串转换成char数组new string(char[] chs)：能够将char数组转换为字符串 字符串的连接+，两边只要有一个是字符串类型，另一个也会被自动转换成字符串类型一切类型都可以调用.ToString()方法转换成字符串类型 字符串提供的各种方法 Length:获取当前字符串中字符的个数 ToUpper(): 将字符转换成大写形式 ToLower():将字符串转换成小写形式 Equals(lessonTwo,StringComparison.OrdinalIgnoreCase):比较两个字符串, Split():分割字符串,返回字符串类型的数组. Substring():解决字符串,在截取的时候包含要截取的那个位置. IndexOf():判断莱个字符串在字符串中第一次出现的位置,如果没有返回-1 LastIndexof():判断某个字符串在字符串中最后一次出现的位置,如果没有同 StartsWith():判断以. 开始 EndsWith():判断以 .结束 Replace():将字符串中某个字符串替换成一个新的字符串 Contains():判断某个字符串是否包含指定的字符串 Trim():去掉字符串中前后的空格 TrimEnd():去掉字符串中结尾的空格 Trimstart():去掉字符串中前面的空格 string.IsNullOrEmpty):判断一个字符串是否为空或者为null string.Join():将数组按照指定的字符串连接,返回一个字符串. 5、继承我们可能会在一些类中，写一些重复的成员，我们可以将这些重复的成员，单独的封装到一个类中，作为这些类的父类。Student Teacher Driver 子类 派生类Person 父类 基类 子类继承了父类，那么子类从父类那里继承过来了什么？首先，子类继承了父类的属性和方法，但是子类并没有继承父类的私有字段。问题：子类有没有继承父类的构造函数？答：子类并没有继承父类的构造函数，但是。子类会默认的调用父类无参数的构造函数，创建父类对象，让子类可以使用父类中的成员。所以，如果在父类中重新写了一个有参数的构造函数之后，那个无参数的就被干掉了，子类就调用不到了，所以子类会报错。 解决方法：在在父类中重新写一个无参数的构造函数。在子类中显示的调用父类的构造函数，使用关键字:base() 6、继承的特性继承的单根性：一个子类只能有一个父类继承的传递性 7、查看类图 8、object是所有类的基类。 十一天1 里式转换子类可以赋值给父类如果父类中装的是子类对象，那么可以讲这个父类强转为子类对象。2、子类对象可以调用父类中的成员，但是父类对象永远都只能调用自己的成员。3、is: 表示类型转换，如果能够转换成功，则返回一个true，否则返回一个false。as: 表示类型转换，如果能够准换则返回对应的对象，否则返回一个null4、protected受保护的：可以在当前类的内部以及该类的子类中访问。5、ArrayList集合的长度问题每次集合中实际包含的元素个数(count)超过了可以包含的元素的个数(capcity)的时候，集合就会像内存中申请多开辟一倍的空间，来保证集合的长度一直够用。","categories":[{"name":"后端","slug":"后端","permalink":"https://rongone.github.io/categories/后端/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://rongone.github.io/tags/C/"}]}]}